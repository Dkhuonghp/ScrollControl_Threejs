{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lexer = exports.LexerDefinitionErrorType = void 0;\n\nvar lexer_1 = require(\"./lexer\");\n\nvar noop_1 = __importDefault(require(\"lodash/noop\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\n\nvar last_1 = __importDefault(require(\"lodash/last\"));\n\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\n\nvar isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\n\nvar identity_1 = __importDefault(require(\"lodash/identity\"));\n\nvar assign_1 = __importDefault(require(\"lodash/assign\"));\n\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar tokens_1 = require(\"./tokens\");\n\nvar lexer_errors_public_1 = require(\"./lexer_errors_public\");\n\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\n\nvar LexerDefinitionErrorType;\n\n(function (LexerDefinitionErrorType) {\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n  LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType = exports.LexerDefinitionErrorType || (exports.LexerDefinitionErrorType = {}));\n\nvar DEFAULT_LEXER_CONFIG = {\n  deferDefinitionErrorsHandling: false,\n  positionTracking: \"full\",\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n  ensureOptimizations: false,\n  safeMode: false,\n  errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,\n  traceInitPerf: false,\n  skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\n\nvar Lexer =\n/** @class */\nfunction () {\n  function Lexer(lexerDefinition, config) {\n    if (config === void 0) {\n      config = DEFAULT_LEXER_CONFIG;\n    }\n\n    var _this = this;\n\n    this.lexerDefinition = lexerDefinition;\n    this.lexerDefinitionErrors = [];\n    this.lexerDefinitionWarning = [];\n    this.patternIdxToConfig = {};\n    this.charCodeToPatternIdxToConfig = {};\n    this.modes = [];\n    this.emptyGroups = {};\n    this.trackStartLines = true;\n    this.trackEndLines = true;\n    this.hasCustom = false;\n    this.canModeBeOptimized = {}; // Duplicated from the parser's perf trace trait to allow future extraction\n    // of the lexer to a separate package.\n\n    this.TRACE_INIT = function (phaseDesc, phaseImpl) {\n      // No need to optimize this using NOOP pattern because\n      // It is not called in a hot spot...\n      if (_this.traceInitPerf === true) {\n        _this.traceInitIndent++;\n        var indent = new Array(_this.traceInitIndent + 1).join(\"\\t\");\n\n        if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n          console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n        }\n\n        var _a = (0, utils_1.timer)(phaseImpl),\n            time = _a.time,\n            value = _a.value;\n        /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n\n\n        var traceMethod = time > 10 ? console.warn : console.log;\n\n        if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n          traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n        }\n\n        _this.traceInitIndent--;\n        return value;\n      } else {\n        return phaseImpl();\n      }\n    };\n\n    if (typeof config === \"boolean\") {\n      throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" + \"a boolean 2nd argument is no longer supported\");\n    } // todo: defaults func?\n\n\n    this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);\n    var traceInitVal = this.config.traceInitPerf;\n\n    if (traceInitVal === true) {\n      this.traceInitMaxIdent = Infinity;\n      this.traceInitPerf = true;\n    } else if (typeof traceInitVal === \"number\") {\n      this.traceInitMaxIdent = traceInitVal;\n      this.traceInitPerf = true;\n    }\n\n    this.traceInitIndent = -1;\n    this.TRACE_INIT(\"Lexer Constructor\", function () {\n      var actualDefinition;\n      var hasOnlySingleMode = true;\n\n      _this.TRACE_INIT(\"Lexer Config handling\", function () {\n        if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n          // optimized built-in implementation for the defaults definition of lineTerminators\n          _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;\n        } else {\n          if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n            throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" + \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n          }\n        }\n\n        if (config.safeMode && config.ensureOptimizations) {\n          throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n        }\n\n        _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n        _this.trackEndLines = /full/i.test(_this.config.positionTracking); // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n\n        if ((0, isArray_1.default)(lexerDefinition)) {\n          actualDefinition = {\n            modes: {\n              defaultMode: (0, clone_1.default)(lexerDefinition)\n            },\n            defaultMode: lexer_1.DEFAULT_MODE\n          };\n        } else {\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\n          hasOnlySingleMode = false;\n          actualDefinition = (0, clone_1.default)(lexerDefinition);\n        }\n      });\n\n      if (_this.config.skipValidations === false) {\n        _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n          _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n\n        _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n          _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n        });\n      } // for extra robustness to avoid throwing an none informative error message\n\n\n      actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {}; // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\n\n      (0, forEach_1.default)(actualDefinition.modes, function (currModeValue, currModeName) {\n        actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function (currTokType) {\n          return (0, isUndefined_1.default)(currTokType);\n        });\n      });\n      var allModeNames = (0, keys_1.default)(actualDefinition.modes);\n      (0, forEach_1.default)(actualDefinition.modes, function (currModDef, currModName) {\n        _this.TRACE_INIT(\"Mode: <\".concat(currModName, \"> processing\"), function () {\n          _this.modes.push(currModName);\n\n          if (_this.config.skipValidations === false) {\n            _this.TRACE_INIT(\"validatePatterns\", function () {\n              _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));\n            });\n          } // If definition errors were encountered, the analysis phase may fail unexpectedly/\n          // Considering a lexer with definition errors may never be used, there is no point\n          // to performing the analysis anyhow...\n\n\n          if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {\n            (0, tokens_1.augmentTokenTypes)(currModDef);\n            var currAnalyzeResult_1;\n\n            _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n              currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {\n                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                positionTracking: config.positionTracking,\n                ensureOptimizations: config.ensureOptimizations,\n                safeMode: config.safeMode,\n                tracer: _this.TRACE_INIT\n              });\n            });\n\n            _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;\n            _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n            _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n            _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n            _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;\n          }\n        });\n      });\n      _this.defaultMode = actualDefinition.defaultMode;\n\n      if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {\n        var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function (error) {\n          return error.message;\n        });\n        var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n        throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n      } // Only print warning if there are no errors, This will avoid pl\n\n\n      (0, forEach_1.default)(_this.lexerDefinitionWarning, function (warningDescriptor) {\n        (0, utils_1.PRINT_WARNING)(warningDescriptor.message);\n      });\n\n      _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n        // Choose the relevant internal implementations for this specific parser.\n        // These implementations should be in-lined by the JavaScript engine\n        // to provide optimal performance in each scenario.\n        if (lexer_1.SUPPORT_STICKY) {\n          _this.chopInput = identity_1.default;\n          _this.match = _this.matchWithTest;\n        } else {\n          _this.updateLastIndex = noop_1.default;\n          _this.match = _this.matchWithExec;\n        }\n\n        if (hasOnlySingleMode) {\n          _this.handleModes = noop_1.default;\n        }\n\n        if (_this.trackStartLines === false) {\n          _this.computeNewColumn = identity_1.default;\n        }\n\n        if (_this.trackEndLines === false) {\n          _this.updateTokenEndLineColumnLocation = noop_1.default;\n        }\n\n        if (/full/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createFullToken;\n        } else if (/onlyStart/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createStartOnlyToken;\n        } else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n          _this.createTokenInstance = _this.createOffsetOnlyToken;\n        } else {\n          throw Error(\"Invalid <positionTracking> config option: \\\"\".concat(_this.config.positionTracking, \"\\\"\"));\n        }\n\n        if (_this.hasCustom) {\n          _this.addToken = _this.addTokenUsingPush;\n          _this.handlePayload = _this.handlePayloadWithCustom;\n        } else {\n          _this.addToken = _this.addTokenUsingMemberAccess;\n          _this.handlePayload = _this.handlePayloadNoCustom;\n        }\n      });\n\n      _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n        var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n          if (canBeOptimized === false) {\n            cannotBeOptimized.push(modeName);\n          }\n\n          return cannotBeOptimized;\n        }, []);\n\n        if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {\n          throw Error(\"Lexer Modes: < \".concat(unOptimizedModes.join(\", \"), \" > cannot be optimized.\\n\") + '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' + \"\\t Or inspect the console log for details on how to resolve these issues.\");\n        }\n      });\n\n      _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n        (0, reg_exp_parser_1.clearRegExpParserCache)();\n      });\n\n      _this.TRACE_INIT(\"toFastProperties\", function () {\n        (0, utils_1.toFastProperties)(_this);\n      });\n    });\n  }\n\n  Lexer.prototype.tokenize = function (text, initialMode) {\n    if (initialMode === void 0) {\n      initialMode = this.defaultMode;\n    }\n\n    if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {\n      var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function (error) {\n        return error.message;\n      });\n      var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n      throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n    }\n\n    return this.tokenizeInternal(text, initialMode);\n  }; // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n  // This is intentional due to performance considerations.\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\n  // for `tsc` to always understand it is \"safe\"\n\n\n  Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n    var _this = this;\n\n    var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n    var orgText = text;\n    var orgLength = orgText.length;\n    var offset = 0;\n    var matchedTokensIndex = 0; // initializing the tokensArray to the \"guessed\" size.\n    // guessing too little will still reduce the number of array re-sizes on pushes.\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\n\n    var guessedNumberOfTokens = this.hasCustom ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n    : Math.floor(text.length / 10);\n    var matchedTokens = new Array(guessedNumberOfTokens);\n    var errors = [];\n    var line = this.trackStartLines ? 1 : undefined;\n    var column = this.trackStartLines ? 1 : undefined;\n    var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);\n    var trackLines = this.trackStartLines;\n    var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n    var currModePatternsLength = 0;\n    var patternIdxToConfig = [];\n    var currCharCodeToPatternIdxToConfig = [];\n    var modeStack = [];\n    var emptyArray = [];\n    Object.freeze(emptyArray);\n    var getPossiblePatterns;\n\n    function getPossiblePatternsSlow() {\n      return patternIdxToConfig;\n    }\n\n    function getPossiblePatternsOptimized(charCode) {\n      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);\n      var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n\n      if (possiblePatterns === undefined) {\n        return emptyArray;\n      } else {\n        return possiblePatterns;\n      }\n    }\n\n    var pop_mode = function pop_mode(popToken) {\n      // TODO: perhaps avoid this error in the edge case there is no more input?\n      if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n      // So no error should occur.\n      popToken.tokenType.PUSH_MODE === undefined) {\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n        var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n\n        errors.push({\n          offset: popToken.startOffset,\n          line: popToken.startLine,\n          column: popToken.startColumn,\n          length: popToken.image.length,\n          message: msg_1\n        });\n      } else {\n        modeStack.pop();\n        var newMode = (0, last_1.default)(modeStack);\n        patternIdxToConfig = _this.patternIdxToConfig[newMode];\n        currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];\n        currModePatternsLength = patternIdxToConfig.length;\n        var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n          getPossiblePatterns = getPossiblePatternsOptimized;\n        } else {\n          getPossiblePatterns = getPossiblePatternsSlow;\n        }\n      }\n    };\n\n    function push_mode(newMode) {\n      modeStack.push(newMode);\n      currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\n      currModePatternsLength = patternIdxToConfig.length;\n      currModePatternsLength = patternIdxToConfig.length;\n      var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n        getPossiblePatterns = getPossiblePatternsOptimized;\n      } else {\n        getPossiblePatterns = getPossiblePatternsSlow;\n      }\n    } // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n    // seem to matter performance wise.\n\n\n    push_mode.call(this, initialMode);\n    var currConfig;\n\n    while (offset < orgLength) {\n      matchedImage = null;\n      var nextCharCode = orgText.charCodeAt(offset);\n      var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n      var chosenPatternsLength = chosenPatternIdxToConfig.length;\n\n      for (i = 0; i < chosenPatternsLength; i++) {\n        currConfig = chosenPatternIdxToConfig[i];\n        var currPattern = currConfig.pattern;\n        payload = null; // manually in-lined because > 600 chars won't be in-lined in V8\n\n        var singleCharCode = currConfig.short;\n\n        if (singleCharCode !== false) {\n          if (nextCharCode === singleCharCode) {\n            // single character string\n            matchedImage = currPattern;\n          }\n        } else if (currConfig.isCustom === true) {\n          match = currPattern.exec(orgText, offset, matchedTokens, groups);\n\n          if (match !== null) {\n            matchedImage = match[0];\n\n            if (match.payload !== undefined) {\n              payload = match.payload;\n            }\n          } else {\n            matchedImage = null;\n          }\n        } else {\n          this.updateLastIndex(currPattern, offset);\n          matchedImage = this.match(currPattern, text, offset);\n        }\n\n        if (matchedImage !== null) {\n          // even though this pattern matched we must try a another longer alternative.\n          // this can be used to prioritize keywords over identifiers\n          longerAlt = currConfig.longerAlt;\n\n          if (longerAlt !== undefined) {\n            // TODO: micro optimize, avoid extra prop access\n            // by saving/linking longerAlt on the original config?\n            var longerAltLength = longerAlt.length;\n\n            for (k = 0; k < longerAltLength; k++) {\n              var longerAltConfig = patternIdxToConfig[longerAlt[k]];\n              var longerAltPattern = longerAltConfig.pattern;\n              altPayload = null; // single Char can never be a longer alt so no need to test it.\n              // manually in-lined because > 600 chars won't be in-lined in V8\n\n              if (longerAltConfig.isCustom === true) {\n                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n\n                if (match !== null) {\n                  matchAltImage = match[0];\n\n                  if (match.payload !== undefined) {\n                    altPayload = match.payload;\n                  }\n                } else {\n                  matchAltImage = null;\n                }\n              } else {\n                this.updateLastIndex(longerAltPattern, offset);\n                matchAltImage = this.match(longerAltPattern, text, offset);\n              }\n\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                matchedImage = matchAltImage;\n                payload = altPayload;\n                currConfig = longerAltConfig; // Exit the loop early after matching one of the longer alternatives\n                // The first matched alternative takes precedence\n\n                break;\n              }\n            }\n          }\n\n          break;\n        }\n      } // successful match\n\n\n      if (matchedImage !== null) {\n        imageLength = matchedImage.length;\n        group = currConfig.group;\n\n        if (group !== undefined) {\n          tokType = currConfig.tokenTypeIdx; // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n          // createFullToken method\n\n          newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n          this.handlePayload(newToken, payload); // TODO: optimize NOOP in case there are no special groups?\n\n          if (group === false) {\n            matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n          } else {\n            groups[group].push(newToken);\n          }\n        }\n\n        text = this.chopInput(text, imageLength);\n        offset = offset + imageLength; // TODO: with newlines the column may be assigned twice\n\n        column = this.computeNewColumn(column, imageLength);\n\n        if (trackLines === true && currConfig.canLineTerminator === true) {\n          var numOfLTsInMatch = 0;\n          var foundTerminator = void 0;\n          var lastLTEndOffset = void 0;\n          lineTerminatorPattern.lastIndex = 0;\n\n          do {\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\n\n            if (foundTerminator === true) {\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n              numOfLTsInMatch++;\n            }\n          } while (foundTerminator === true);\n\n          if (numOfLTsInMatch !== 0) {\n            line = line + numOfLTsInMatch;\n            column = imageLength - lastLTEndOffset;\n            this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n          }\n        } // will be NOOP if no modes present\n\n\n        this.handleModes(currConfig, pop_mode, push_mode, newToken);\n      } else {\n        // error recovery, drop characters until we identify a valid token's start point\n        var errorStartOffset = offset;\n        var errorLine = line;\n        var errorColumn = column;\n        var foundResyncPoint = false;\n\n        while (!foundResyncPoint && offset < orgLength) {\n          // drop chars until we succeed in matching something\n          droppedChar = orgText.charCodeAt(offset); // Identity Func (when sticky flag is enabled)\n\n          text = this.chopInput(text, 1);\n          offset++;\n\n          for (j = 0; j < currModePatternsLength; j++) {\n            var currConfig_1 = patternIdxToConfig[j];\n            var currPattern = currConfig_1.pattern; // manually in-lined because > 600 chars won't be in-lined in V8\n\n            var singleCharCode = currConfig_1.short;\n\n            if (singleCharCode !== false) {\n              if (orgText.charCodeAt(offset) === singleCharCode) {\n                // single character string\n                foundResyncPoint = true;\n              }\n            } else if (currConfig_1.isCustom === true) {\n              foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n            } else {\n              this.updateLastIndex(currPattern, offset);\n              foundResyncPoint = currPattern.exec(text) !== null;\n            }\n\n            if (foundResyncPoint === true) {\n              break;\n            }\n          }\n        }\n\n        errLength = offset - errorStartOffset; // at this point we either re-synced or reached the end of the input text\n\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n        errors.push({\n          offset: errorStartOffset,\n          line: errorLine,\n          column: errorColumn,\n          length: errLength,\n          message: msg\n        });\n      }\n    } // if we do have custom patterns which push directly into the\n    // TODO: custom tokens should not push directly??\n\n\n    if (!this.hasCustom) {\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\n      matchedTokens.length = matchedTokensIndex;\n    }\n\n    return {\n      tokens: matchedTokens,\n      groups: groups,\n      errors: errors\n    };\n  };\n\n  Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n    if (config.pop === true) {\n      // need to save the PUSH_MODE property as if the mode is popped\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n      var pushMode = config.push;\n      pop_mode(newToken);\n\n      if (pushMode !== undefined) {\n        push_mode.call(this, pushMode);\n      }\n    } else if (config.push !== undefined) {\n      push_mode.call(this, config.push);\n    }\n  };\n\n  Lexer.prototype.chopInput = function (text, length) {\n    return text.substring(length);\n  };\n\n  Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n    regExp.lastIndex = newLastIndex;\n  }; // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n\n\n  Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n    var lastCharIsLT, fixForEndingInLT;\n\n    if (group !== undefined) {\n      // a none skipped multi line Token, need to update endLine/endColumn\n      lastCharIsLT = lastLTIdx === imageLength - 1;\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\n\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n        newToken.endLine = line + fixForEndingInLT; // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n        // inclusive to exclusive range.\n\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\n      } // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n\n    }\n  };\n\n  Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n    return oldColumn + imageLength;\n  };\n\n  Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      startLine: startLine,\n      startColumn: startColumn,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n    return {\n      image: image,\n      startOffset: startOffset,\n      endOffset: startOffset + imageLength - 1,\n      startLine: startLine,\n      endLine: startLine,\n      startColumn: startColumn,\n      endColumn: startColumn + imageLength - 1,\n      tokenTypeIdx: tokenTypeIdx,\n      tokenType: tokenType\n    };\n  };\n\n  Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n    tokenVector.push(tokenToAdd);\n    return index;\n  };\n\n  Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n    tokenVector[index] = tokenToAdd;\n    index++;\n    return index;\n  };\n\n  Lexer.prototype.handlePayloadNoCustom = function (token, payload) {};\n\n  Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n    if (payload !== null) {\n      token.payload = payload;\n    }\n  };\n\n  Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n    var found = pattern.test(text);\n\n    if (found === true) {\n      return text.substring(offset, pattern.lastIndex);\n    }\n\n    return null;\n  };\n\n  Lexer.prototype.matchWithExec = function (pattern, text) {\n    var regExpArray = pattern.exec(text);\n    return regExpArray !== null ? regExpArray[0] : null;\n  };\n\n  Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" + \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n  Lexer.NA = /NOT_APPLICABLE/;\n  return Lexer;\n}();\n\nexports.Lexer = Lexer;","map":{"version":3,"sources":["../../../src/scan/lexer_public.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lexer = exports.LexerDefinitionErrorType = void 0;\nvar lexer_1 = require(\"./lexer\");\nvar noop_1 = __importDefault(require(\"lodash/noop\"));\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\nvar last_1 = __importDefault(require(\"lodash/last\"));\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\nvar map_1 = __importDefault(require(\"lodash/map\"));\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\nvar identity_1 = __importDefault(require(\"lodash/identity\"));\nvar assign_1 = __importDefault(require(\"lodash/assign\"));\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\nvar utils_1 = require(\"@chevrotain/utils\");\nvar tokens_1 = require(\"./tokens\");\nvar lexer_errors_public_1 = require(\"./lexer_errors_public\");\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MISSING_PATTERN\"] = 0] = \"MISSING_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_PATTERN\"] = 1] = \"INVALID_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EOI_ANCHOR_FOUND\"] = 2] = \"EOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNSUPPORTED_FLAGS_FOUND\"] = 3] = \"UNSUPPORTED_FLAGS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"DUPLICATE_PATTERNS_FOUND\"] = 4] = \"DUPLICATE_PATTERNS_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"INVALID_GROUP_TYPE_FOUND\"] = 5] = \"INVALID_GROUP_TYPE_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"PUSH_MODE_DOES_NOT_EXIST\"] = 6] = \"PUSH_MODE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\"] = 7] = \"MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\"] = 8] = \"MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\"] = 9] = \"MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\"] = 10] = \"LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"SOI_ANCHOR_FOUND\"] = 11] = \"SOI_ANCHOR_FOUND\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"EMPTY_MATCH_PATTERN\"] = 12] = \"EMPTY_MATCH_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"NO_LINE_BREAKS_FLAGS\"] = 13] = \"NO_LINE_BREAKS_FLAGS\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"UNREACHABLE_PATTERN\"] = 14] = \"UNREACHABLE_PATTERN\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"IDENTIFY_TERMINATOR\"] = 15] = \"IDENTIFY_TERMINATOR\";\n    LexerDefinitionErrorType[LexerDefinitionErrorType[\"CUSTOM_LINE_BREAK\"] = 16] = \"CUSTOM_LINE_BREAK\";\n})(LexerDefinitionErrorType = exports.LexerDefinitionErrorType || (exports.LexerDefinitionErrorType = {}));\nvar DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: \"full\",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: [\"\\n\", \"\\r\"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nvar Lexer = /** @class */ (function () {\n    function Lexer(lexerDefinition, config) {\n        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }\n        var _this = this;\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        // Duplicated from the parser's perf trace trait to allow future extraction\n        // of the lexer to a separate package.\n        this.TRACE_INIT = function (phaseDesc, phaseImpl) {\n            // No need to optimize this using NOOP pattern because\n            // It is not called in a hot spot...\n            if (_this.traceInitPerf === true) {\n                _this.traceInitIndent++;\n                var indent = new Array(_this.traceInitIndent + 1).join(\"\\t\");\n                if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n                    console.log(\"\".concat(indent, \"--> <\").concat(phaseDesc, \">\"));\n                }\n                var _a = (0, utils_1.timer)(phaseImpl), time = _a.time, value = _a.value;\n                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n                var traceMethod = time > 10 ? console.warn : console.log;\n                if (_this.traceInitIndent < _this.traceInitMaxIdent) {\n                    traceMethod(\"\".concat(indent, \"<-- <\").concat(phaseDesc, \"> time: \").concat(time, \"ms\"));\n                }\n                _this.traceInitIndent--;\n                return value;\n            }\n            else {\n                return phaseImpl();\n            }\n        };\n        if (typeof config === \"boolean\") {\n            throw Error(\"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\n                \"a boolean 2nd argument is no longer supported\");\n        }\n        // todo: defaults func?\n        this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config);\n        var traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === \"number\") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT(\"Lexer Constructor\", function () {\n            var actualDefinition;\n            var hasOnlySingleMode = true;\n            _this.TRACE_INIT(\"Lexer Config handling\", function () {\n                if (_this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (_this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error(\"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\n                            \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error('\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.');\n                }\n                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);\n                _this.trackEndLines = /full/i.test(_this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if ((0, isArray_1.default)(lexerDefinition)) {\n                    actualDefinition = {\n                        modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },\n                        defaultMode: lexer_1.DEFAULT_MODE\n                    };\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = (0, clone_1.default)(lexerDefinition);\n                }\n            });\n            if (_this.config.skipValidations === false) {\n                _this.TRACE_INIT(\"performRuntimeChecks\", function () {\n                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n                _this.TRACE_INIT(\"performWarningRuntimeChecks\", function () {\n                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            (0, forEach_1.default)(actualDefinition.modes, function (currModeValue, currModeName) {\n                actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function (currTokType) { return (0, isUndefined_1.default)(currTokType); });\n            });\n            var allModeNames = (0, keys_1.default)(actualDefinition.modes);\n            (0, forEach_1.default)(actualDefinition.modes, function (currModDef, currModName) {\n                _this.TRACE_INIT(\"Mode: <\".concat(currModName, \"> processing\"), function () {\n                    _this.modes.push(currModName);\n                    if (_this.config.skipValidations === false) {\n                        _this.TRACE_INIT(\"validatePatterns\", function () {\n                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {\n                        (0, tokens_1.augmentTokenTypes)(currModDef);\n                        var currAnalyzeResult_1;\n                        _this.TRACE_INIT(\"analyzeTokenTypes\", function () {\n                            currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {\n                                lineTerminatorCharacters: _this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: _this.TRACE_INIT\n                            });\n                        });\n                        _this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.patternIdxToConfig;\n                        _this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;\n                        _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);\n                        _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;\n                        _this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult_1.canBeOptimized;\n                    }\n                });\n            });\n            _this.defaultMode = actualDefinition.defaultMode;\n            if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) &&\n                !_this.config.deferDefinitionErrorsHandling) {\n                var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function (error) {\n                    return error.message;\n                });\n                var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n                throw new Error(\"Errors detected in definition of Lexer:\\n\" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            (0, forEach_1.default)(_this.lexerDefinitionWarning, function (warningDescriptor) {\n                (0, utils_1.PRINT_WARNING)(warningDescriptor.message);\n            });\n            _this.TRACE_INIT(\"Choosing sub-methods implementations\", function () {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (lexer_1.SUPPORT_STICKY) {\n                    _this.chopInput = identity_1.default;\n                    _this.match = _this.matchWithTest;\n                }\n                else {\n                    _this.updateLastIndex = noop_1.default;\n                    _this.match = _this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    _this.handleModes = noop_1.default;\n                }\n                if (_this.trackStartLines === false) {\n                    _this.computeNewColumn = identity_1.default;\n                }\n                if (_this.trackEndLines === false) {\n                    _this.updateTokenEndLineColumnLocation = noop_1.default;\n                }\n                if (/full/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createFullToken;\n                }\n                else if (/onlyStart/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(_this.config.positionTracking)) {\n                    _this.createTokenInstance = _this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(\"Invalid <positionTracking> config option: \\\"\".concat(_this.config.positionTracking, \"\\\"\"));\n                }\n                if (_this.hasCustom) {\n                    _this.addToken = _this.addTokenUsingPush;\n                    _this.handlePayload = _this.handlePayloadWithCustom;\n                }\n                else {\n                    _this.addToken = _this.addTokenUsingMemberAccess;\n                    _this.handlePayload = _this.handlePayloadNoCustom;\n                }\n            });\n            _this.TRACE_INIT(\"Failed Optimization Warnings\", function () {\n                var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {\n                    throw Error(\"Lexer Modes: < \".concat(unOptimizedModes.join(\", \"), \" > cannot be optimized.\\n\") +\n                        '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\n                        \"\\t Or inspect the console log for details on how to resolve these issues.\");\n                }\n            });\n            _this.TRACE_INIT(\"clearRegExpParserCache\", function () {\n                (0, reg_exp_parser_1.clearRegExpParserCache)();\n            });\n            _this.TRACE_INIT(\"toFastProperties\", function () {\n                (0, utils_1.toFastProperties)(_this);\n            });\n        });\n    }\n    Lexer.prototype.tokenize = function (text, initialMode) {\n        if (initialMode === void 0) { initialMode = this.defaultMode; }\n        if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {\n            var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function (error) {\n                return error.message;\n            });\n            var allErrMessagesString = allErrMessages.join(\"-----------------------\\n\");\n            throw new Error(\"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\n                allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    };\n    // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is \"safe\"\n    Lexer.prototype.tokenizeInternal = function (text, initialMode) {\n        var _this = this;\n        var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        var orgText = text;\n        var orgLength = orgText.length;\n        var offset = 0;\n        var matchedTokensIndex = 0;\n        // initializing the tokensArray to the \"guessed\" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        var guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        var matchedTokens = new Array(guessedNumberOfTokens);\n        var errors = [];\n        var line = this.trackStartLines ? 1 : undefined;\n        var column = this.trackStartLines ? 1 : undefined;\n        var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);\n        var trackLines = this.trackStartLines;\n        var lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        var currModePatternsLength = 0;\n        var patternIdxToConfig = [];\n        var currCharCodeToPatternIdxToConfig = [];\n        var modeStack = [];\n        var emptyArray = [];\n        Object.freeze(emptyArray);\n        var getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);\n            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        var pop_mode = function (popToken) {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg_1\n                });\n            }\n            else {\n                modeStack.pop();\n                var newMode = (0, last_1.default)(modeStack);\n                patternIdxToConfig = _this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig =\n                    _this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig =\n                this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        var currConfig;\n        while (offset < orgLength) {\n            matchedImage = null;\n            var nextCharCode = orgText.charCodeAt(offset);\n            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            var chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                var currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won't be in-lined in V8\n                var singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        var longerAltLength = longerAlt.length;\n                        for (k = 0; k < longerAltLength; k++) {\n                            var longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            var longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            // single Char can never be a longer alt so no need to test it.\n                            // manually in-lined because > 600 chars won't be in-lined in V8\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== undefined) {\n                                        altPayload = match.payload;\n                                    }\n                                }\n                                else {\n                                    matchAltImage = null;\n                                }\n                            }\n                            else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                // Exit the loop early after matching one of the longer alternatives\n                                // The first matched alternative takes precedence\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    var numOfLTsInMatch = 0;\n                    var foundTerminator = void 0;\n                    var lastLTEndOffset = void 0;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token's start point\n                var errorStartOffset = offset;\n                var errorLine = line;\n                var errorColumn = column;\n                var foundResyncPoint = false;\n                while (!foundResyncPoint && offset < orgLength) {\n                    // drop chars until we succeed in matching something\n                    droppedChar = orgText.charCodeAt(offset);\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        var currConfig_1 = patternIdxToConfig[j];\n                        var currPattern = currConfig_1.pattern;\n                        // manually in-lined because > 600 chars won't be in-lined in V8\n                        var singleCharCode = currConfig_1.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig_1.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg\n                });\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors\n        };\n    };\n    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            var pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    };\n    Lexer.prototype.chopInput = function (text, length) {\n        return text.substring(length);\n    };\n    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    };\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        var lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    };\n    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    };\n    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            startLine: startLine,\n            startColumn: startColumn,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image: image,\n            startOffset: startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine: startLine,\n            endLine: startLine,\n            startColumn: startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx: tokenTypeIdx,\n            tokenType: tokenType\n        };\n    };\n    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    };\n    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    };\n    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };\n    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    };\n    Lexer.prototype.matchWithTest = function (pattern, text, offset) {\n        var found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    };\n    Lexer.prototype.matchWithExec = function (pattern, text) {\n        var regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    };\n    Lexer.SKIPPED = \"This marks a skipped Token pattern, this means each token identified by it will\" +\n        \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\n    Lexer.NA = /NOT_APPLICABLE/;\n    return Lexer;\n}());\nexports.Lexer = Lexer;\n//# sourceMappingURL=lexer_public.js.map"]},"metadata":{},"sourceType":"script"}