"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),t=require("three"),r=require("react"),s=require("react-dom"),o=require("@react-three/fiber"),l=require("react-merge-refs");function n(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function i(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var s=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var f=n(e),c=i(t),a=i(r),u=i(s),d=n(l);const h=a.createContext(null);function p(){return a.useContext(h)}const m=a.forwardRef((({children:e},t)=>{const r=a.useRef(null),s=p(),{width:l,height:n}=o.useThree((e=>e.viewport));return o.useFrame((()=>{r.current.position.x=s.horizontal?-l*(s.pages-1)*s.offset:0,r.current.position.y=s.horizontal?0:n*(s.pages-1)*s.offset})),a.createElement("group",{ref:d.default([t,r])},e)})),v=a.forwardRef((({children:e,style:t,...r},s)=>{const l=p(),n=a.useRef(null),{width:i,height:c}=o.useThree((e=>e.size)),m=a.useContext(o.context);return o.useFrame((()=>{l.delta>l.eps&&(n.current.style.transform=`translate3d(${l.horizontal?-i*(l.pages-1)*l.offset:0}px,${l.horizontal?0:c*(l.pages-1)*-l.offset}px,0)`)})),u.render(a.createElement("div",f.default({ref:d.default([s,n]),style:{...t,position:"absolute",top:0,left:0,willChange:"transform"}},r),a.createElement(h.Provider,{value:l},a.createElement(o.context.Provider,{value:m},e))),l.fixed),null})),y=a.forwardRef((({html:e,...t},r)=>{const s=e?v:m;return a.createElement(s,f.default({ref:r},t))}));exports.Scroll=y,exports.ScrollControls=function({eps:e=1e-5,infinite:t,horizontal:r,pages:s=1,distance:l=1,damping:n=4,children:i}){const{gl:f,size:u,invalidate:d,events:p,raycaster:m}=o.useThree(),[v]=a.useState((()=>document.createElement("div"))),[y]=a.useState((()=>document.createElement("div"))),[g]=a.useState((()=>document.createElement("div"))),w=f.domElement.parentNode,x=a.useRef(0),E=a.useMemo((()=>({el:v,eps:e,fill:y,fixed:g,horizontal:r,damping:n,offset:0,delta:0,scroll:x,pages:s,range(e,t,r=0){const s=e-r,o=s+t+2*r;return this.offset<s?0:this.offset>o?1:(this.offset-s)/(o-s)},curve(e,t,r=0){return Math.sin(this.range(e,t,r)*Math.PI)},visible(e,t,r=0){const s=e-r,o=s+t+2*r;return this.offset>=s&&this.offset<=o}})),[e,n,r,s]);a.useEffect((()=>{v.style.position="absolute",v.style.width="100%",v.style.height="100%",v.style[r?"overflowX":"overflowY"]="auto",v.style[r?"overflowY":"overflowX"]="hidden",v.style.top="0px",v.style.left="0px",g.style.position="sticky",g.style.top="0px",g.style.left="0px",g.style.width="100%",g.style.height="100%",g.style.overflow="hidden",v.appendChild(g),y.style.height=r?"100%":s*l*100+"%",y.style.width=r?s*l*100+"%":"100%",y.style.pointerEvents="none",v.appendChild(y),w.appendChild(v),v[r?"scrollLeft":"scrollTop"]=1;const e=p.connected;requestAnimationFrame((()=>null==p.connect?void 0:p.connect(v)));const t=m.computeOffsets;return m.computeOffsets=({clientX:e,clientY:t})=>({offsetX:e,offsetY:t}),()=>{w.removeChild(v),m.computeOffsets=t,null==p.connect||p.connect(e)}}),[s,l,r,v,y,g,w]),a.useEffect((()=>{const e=u[r?"width":"height"],s=v[r?"scrollWidth":"scrollHeight"],o=s-e;let l=0,n=!1;const i=e=>{if(d(),l=v[r?"scrollLeft":"scrollTop"],x.current=l/o,t){if(!n)if(l>=o){const e=1-E.offset;v[r?"scrollLeft":"scrollTop"]=1,x.current=E.offset=-e,n=!0}else if(l<=0){const e=1+E.offset;v[r?"scrollLeft":"scrollTop"]=s,x.current=E.offset=e,n=!0}n&&setTimeout((()=>n=!1),40)}};v.addEventListener("scroll",i,{passive:!0});const f=e=>v.scrollLeft+=e.deltaY/2;return r&&v.addEventListener("wheel",f,{passive:!0}),()=>{v.removeEventListener("scroll",i),r&&v.removeEventListener("wheel",f)}}),[v,u,t,E,d,r]);let b=0;return o.useFrame(((t,r)=>{E.offset=c.MathUtils.damp(b=E.offset,x.current,n,r),E.delta=c.MathUtils.damp(E.delta,Math.abs(b-E.offset),n,r),E.delta>e&&d()})),a.createElement(h.Provider,{value:E},i)},exports.useScroll=p;
