"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),t=require("three"),r=require("react"),n=require("@react-three/fiber"),a=require("react-merge-refs"),u=require("../helpers/Position.cjs.js");function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function i(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var c=o(e),s=i(t),l=i(r),f=o(a);let d,b;const m=l.createContext(null),p=new s.Matrix4,y=new s.Vector3,g=new s.Color,h=l.forwardRef((({children:e,range:t,limit:r=1e3,...a},u)=>{const o=l.useRef(null),[i,h]=l.useState([]),[[x,j]]=l.useState((()=>[new Float32Array(3*r),new Float32Array([...new Array(3*r)].map((()=>1)))]));l.useLayoutEffect((()=>{o.current.geometry.drawRange.count=Math.min(r,void 0!==t?t:r,i.length)}),[i,t]),l.useEffect((()=>{o.current.geometry.attributes.position.needsUpdate=!0})),n.useFrame((()=>{for(o.current.updateMatrix(),o.current.updateMatrixWorld(),p.copy(o.current.matrixWorld).invert(),d=0;d<i.length;d++)b=i[d].current,b.getWorldPosition(y).applyMatrix4(p),y.x===x[3*d]&&y.y===x[3*d+1]&&y.z===x[3*d+2]||(y.toArray(x,3*d),o.current.geometry.attributes.position.needsUpdate=!0,b.matrixWorldNeedsUpdate=!0),b.color.equals(g.fromArray(j,3*d))||(b.color.toArray(j,3*d),o.current.geometry.attributes.color.needsUpdate=!0)}));const v=l.useMemo((()=>{const e={};for(d=0;d<i.length;d++){var t;Object.assign(e,null==(t=i[d].current)?void 0:t.__r3f.handlers)}return Object.keys(e).reduce(((e,t)=>({...e,[t]:e=>{var r,n,a;const u=null==(r=i[e.index])?void 0:r.current;return null==u||null==(n=u.__r3f)||null==(a=n.handlers)?void 0:a[t]({...e,object:u})}})),{})}),[e,i]),w=l.useMemo((()=>({subscribe:e=>(h((t=>[...t,e])),()=>h((t=>t.filter((t=>t.current!==e.current)))))})),[]);return l.createElement("points",c.default({matrixAutoUpdate:!1,ref:f.default([u,o])},v,a),l.createElement("bufferGeometry",null,l.createElement("bufferAttribute",{attachObject:["attributes","position"],count:x.length/3,array:x,itemSize:3,usage:s.DynamicDrawUsage}),l.createElement("bufferAttribute",{attachObject:["attributes","color"],count:j.length/3,array:j,itemSize:3,usage:s.DynamicDrawUsage})),l.createElement(m.Provider,{value:w},e))})),x=l.forwardRef((({children:e,...t},r)=>{l.useMemo((()=>n.extend({Position:u.Position})),[]);const a=l.useRef(),{subscribe:o}=l.useContext(m);return l.useLayoutEffect((()=>o(a)),[]),l.createElement("position",c.default({ref:f.default([r,a])},t),e)}));exports.Point=x,exports.Points=h;
